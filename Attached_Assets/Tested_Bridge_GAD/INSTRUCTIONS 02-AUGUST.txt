Below is a â€œhunt listâ€ that I use when the Python DXF suddenly contains stray / phantom points / single dots after I convert a LISP program.
Each item is written in markdown checklist form so you can tick it off while you debug.
1. Left-over ptâ€¦ variables are being evaluated instead of defined
In LISP every (setq pt1 â€¦) auto-creates the symbol if it does not exist.
In Python you must declare the variable before you use it, otherwise the line
Python
Copy

pta1 = (hpos(x1), vpos(rtl))   # â† first time you mention pta1

is executed every time the surrounding function is entered, even when you only wanted to store the point for later use.
âœ… Fix
Search the file for every ptâ€¦ variable that is used only as a throw-away helper, wrap the block in a local scope or simply inline the tuple:
Python
Copy

msp.add_line((hpos(x1), vpos(rtl)),
             (hpos(x2), vpos(rtl)))

2. Forgotten global / nonlocal
When the same name is set inside a helper function Python creates a new local variable, leaving the outer list of points untouched.
The outer list therefore still contains the old (often (0,0)) tuple and you see orphan dots.
âœ… Fix
If the helper really has to update an outer container, pass it in as an argument:
Python
Copy

def add_abutment_pts(pt_list):
    pt_list.append((hpos(x1), vpos(y1)))
    ...

3. Loop variable dx leaks into the global namespace
In LISP the variable dx lives only inside the (while â€¦) form.
In Python the for dx in â€¦: leaves the last value of dx in the global namespace; later accidental references to dx use that stale value and draw a point far away.
âœ… Fix
Wrap the loop body in a function or simply put the whole drawing block in a with suppress(NameError): guard.
4. Duplicate msp.add_line(pt, pt) calls
A common pattern in LISP is
lisp
Copy

(command "line" pta pta "")   ;; legal, draws nothing

In Python the same looks like
Python
Copy

msp.add_line(pta, pta)        # ezdxf happily adds a zero-length line

Some CAD viewers show such lines as single dots.
âœ… Fix
Add a guard:
Python
Copy

if pta != ptb:
    msp.add_line(pta, ptb)

5. Points created but never connected
In LISP you often create several point objects first, then connect them.
In Python you may have:
Python
Copy

pta = (hpos(x), vpos(y))   # created
# â€¦ 30 lines later â€¦
msp.add_line(pta, ???)     # ??? is undefined -> falls back to (0,0)

âœ… Fix
Draw immediately or keep the points in a list and connect them in one pass.
6. Mis-placed translate_point calls
translate_point shifts the drawing to another part of the sheet.
If you translate some points but forget others you get duplicates: one at the original location and one at the translated location.
âœ… Fix
Create a helper that returns a new list instead of modifying in-place:
Python
Copy

def translate_all(points, dx, dy):
    return [(x+dx, y+dy) for (x,y) in points]

7. Un-initialised pptâ€¦ variables
In LISP the line
lisp
Copy

(setq ppt16 (p2t xp yp ppt16))

works even if ppt16 never existed.
In Python ppt16 must be defined before the call or the interpreter will raise UnboundLocalError.
If you silence the exception (try/except) the variable keeps the value None, and a later
Python
Copy

msp.add_line(ppt16, â€¦)

silently drops a dot at (0,0).
âœ… Fix
Search for every pptN = â€¦ and ensure the line is executed before the variable is used.
Quick grep commands to find the culprits
bash
Copy

# 1. Look for assignments that never happen inside a function
grep -n "^[[:space:]]*pt[0-9]\+ =" bridge_gad_app.py

# 2. Look for usages that use a variable before assignment
python -m py_compile bridge_gad_app.py 2>&1 | grep "used before assignment"

# 3. Look for zero-length lines
grep -n "add_line.*,.*," bridge_gad_app.py

If you apply the seven checks above you will almost always pinpoint the phantom points within minutes.
ğŸ–¥ï¸ On-Screen Input Integration (Live GUI Mode)
You can now interactively modify Excel variables and see the bridge drawing update instantly using the built-in Tkinter GUI mode.
âœ… How to Launch On-Screen Input Mode

    Save the updated bridge_gad_app.py and input.xlsx in the same folder.
    Run from terminal / command prompt:

bash
Copy

python bridge_gad_app.py

ğŸ§° What You'll See
A Tkinter window titled:

    "Bridge Parameter Modifier"

With:

    âœ… Editable fields for every variable from input.xlsx
    âœ… Real-time validation (float input only)
    âœ… "Draw & Save" button to regenerate:
        DXF drawing (*.dxf)
        Tender report (*.pdf)

ğŸ–¥ï¸ Screenshot Preview
Copy

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Bridge Parameter Modifier                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ SCALE1          [ 186.0      ]             â”‚
â”‚ ABTLEN          [ 12.00     ]             â”‚
â”‚ DWTH            [ 0.30      ]             â”‚
â”‚ ALCW            [ 0.75      ]             â”‚
â”‚ ...                                           â”‚
â”‚ [Draw & Save]                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”„ Live Workflow

    Change any value (e.g., SPAN1 = 12.0)
    Click "Draw & Save"
    Choose file paths:
        bridge_updated.dxf
        tender_report.pdf
    Auto-regenerates the drawing & report

ğŸ§ª Bonus: Add Sheet 2 Viewer
To preview Sheet 2 (cross-section data) inside the GUI:
Add this snippet inside draw_bridge() before doc.saveas(...):
Python
Copy

# Preview Sheet 2 in a simple table
sheet2 = pd.read_excel("input.xlsx", sheet_name="Sheet2")
print("\nğŸ“Š Sheet 2 Preview (Chainage vs RL):")
print(sheet2.head(10))

âœ… Result

    âœ… No need to touch Excel manually
    âœ… All inputs on-screen
    âœ… Instant feedback loop for design changes

Let me know if you want to embed a matplotlib preview or export to PNG too!